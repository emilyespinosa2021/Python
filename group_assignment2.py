# -*- coding: utf-8 -*-
"""Group_Assignment2.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1mnfO_1U0N1t_pVxzP4NaOQF9PrjwjiIM

# **Warm Up:**

Ques 1: Write a higher-order function n_times that takes a function f and a number n, and returns a new function that applies f to its input n times. For example, if f is a function that adds 2, n_times(f, 3)(5) should return 11 (because 5 + 2 + 2 + 2 = 11)
"""

def n_times(f, n, x):
  if n == 0:
    return x
  else:
    return n_times(n-1, f, f(x))
def add(x):
  return x+2
result = n_times(3, add, 5)
print(result)

"""Ques 2: Write a higher-order function compose that takes two functions f and g as arguments and returns a new function that, when called, returns the result of g(f(x))."""

def funct(f, g):
  def h(x):
    return g(f(x))
  return h

"""## **Use python Higher order functions to solve this problem:**

**The Multi-layered Transformation Challenge**

You're given a list of strings representing scientific observations. Each string consists of alphabets, numbers, and sometimes other characters. Your goal is to process this list in a way that extracts numerical information and provides insights.

observations = ["a2b3c4", "d5e1f8g7", "h6i9j0", "k5l3m4", "n2o3", "p1q2r8s7t6"]

Perform the following operations on the observations list:

1. Filtering: Only keep the strings that have more than 2 digits in them.

2. Transformation: Convert the filtered strings into lists of integers extracted from them.

3. Sorting: For each list of integers, sort the numbers in decreasing order.

4. Aggregation: For each sorted list of integers, calculate the average.

Return a list of tuples. Each tuple should contain two items: the first item being the original string observation, and the second item being the average of the numbers extracted from that observation.
"""

observations = ["a2b3c4", "d5e1f8g7", "h6i9j0", "k5l3m4", "n2o3", "p1q2r8s7t6"]
filtering = list(filter(lambda x: len([i for i in x if i.isdigit()])>2, observations))
filtering

"""# Let's write a custom higher-order function

DNA = "ATCTATCTATATCTTATCGTATGTGTACTATGTACTTGATT"
- building blocks of DNA: A, C, G, T

### Sliding window of k-bases: k = 4

Example kmers of 4:
ATCT
TCTA
CTAT
TCGT

#### I want to know the AT content in each k-mer
#### I want to know if there are any 'CG's in the k-mer

## Write a higher order function called `get_kmers_info` with three arguments: dna, k, analyze_kmer

`get_kmers_info(DNA, 4, getAT)`
"""

# dna = ABCD
# printing K mers
# kmers of size 3 for the above dns = ABCD will be [ABC BCD]
# Part A, create a LC which calculates kmers in a given dna seq for a given k
DNA = "ATCTATCTATATCTTATCGTATGTGTACTATGTACTTGATT"
length = len(DNA)
acount = DNA.count('A')
tcount = DNA.count('T')
ATcontent = (acount + tcount)/length

get_kmers_info("ATC", 1, AT_content)

# now start writing the higher order function:

# example function call:
get_kmers_info("ATC", 1, AT_content)