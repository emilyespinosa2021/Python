# -*- coding: utf-8 -*-
"""SOL_hands_on_4.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rDlNlN-LpKD2ytO_CAnuKYkXQ1Elr29L

# Problem One: Complex data structure
`gene_expression.csv` contains a header row with the patient ID, and each of row contains the gene expression level for each gene for each patient.
Here is an example of the csv file (also known as comma separated values):




 `,Patient1,Patient2,Patient3,Patient4`<br>
 `Gene1,23.56,94.28,38.59,28.04`<br>
 `Gene2,219.28,410.38,302.92,204.25`<br>
 `Gene3,92.49,83.20,30.22,83.53`<br>

When you open the csv file with excel or any spreadsheet program, you will see that the data are automatically organized in a table.

|       | Patient1 | Patient2 | Patient3 | Patient4 |
|-------|----------|----------|----------|----------|
| Gene1 | 23.56    | 94.28    | 38.59    | 28.04    |
| Gene2 | 219.28   | 410.38   | 302.92   | 204.25   |
| Gene3 | 92.49    | 83.20    | 30.22    | 83.53    |
<br>

**Write a Python program that reads the content of the input file `gene_expression.csv`, and stores the file content in an appropriate data structure of your choice. Use the data structure and do the following:
a)	Write a function called `get_average_expression(data, gene)` that takes two arguments: the data structure you have created as described above and a gene name. This function computes the average gene expression for the gene and prints the gene name and the average gene expression of the gene to the screen. Run this function with the gene name " YLL053C".**

To read the `gene_expression.csv` file in your Jupyter notebook in Google Colab, first, download the `gene_expression.csv` file from Canvas, and upload load it to your Google Colab environment by running the following lines of code. If you are using your local Juypter notebook, then you can store the csv file in the same directory where you put this hands-on ipynb file. Open the file using the `open()` function.
"""

# Run this cell ONLY if you are using Google Colab to run your Jupyter notebook
# If you use your local Jupyter notebook, then don't run this cell.
from google.colab import files
files_uploaded = files.upload()
my_file = open("gene_expression.csv", "r")
lines = my_file.readlines()

from google.colab import files
files_uploaded = files.upload()

# 1 points 1 for reading and 1 for moving the data into a data structure

#4+2
def gene_average_expression(data, gene):
  for line in lines: # .5 point
    cur = line.split(",") # .5 point
    sum = 0
    if cur[0] == gene: # 1 point
      for i in cur[1:]: # .5 point
        #print(cur[i])
        sum += float(i)
      return sum / (len(cur) - 1) # 1.5 points

print(gene_average_expression(lines, "YLL053C"))

"""# Ques 2
**Create a function called removeDuplicates which will remove the duplicates present in the string if the occur together. Use the stack like data structure to implement your code and get the correct solution.**
"""

#3
def removeDuplicates(test):
  list1 = []
  for a in test: # .5 point
    if list1 and a == list1[-1]: # 1 point
      list1.pop() # .5 point
    list1.append(a) # .5 point
  return "".join(list1) # .5 point
print(removeDuplicates("PPytthoon"))

"""# Ques 3
**Create a function called testBracs which takes in a string containing different parentheses. The function returns true if:**

*   **All opening parentheses have their corresponding closing parentheses and vice versa.**
*   **They are closed in correct order.**

Hint: You will have to use 2 data structures. Use a dictionary to keep note of opening and closing parentheses so that you can use it as refernce and then use a stack for the actual string.
"""

#6
def testBracs(s):
  if len(s) % 2 != 0: # 1 point
    return False
  dict = {'(' : ')', '[' : ']', '{' : '}'} # .5 point
  stack = [] # .5 point
  for i in s:
    if i in dict.keys(): # 1 point
      stack.append(i)
    else:
      if stack == []: # 1 point
        return False
      a = stack.pop() # .5 point
      if i!= dict[a]: # 1 point
        return False
  return stack == [] # .5 point

"""# Problem Two: List Comprehension

Given dictionary is consisted of vehicles and their weights in kilograms.

1.   List item
2.   List item

Contruct a list of the names of vehicles with weights below 2000 kilograms. In the same list comprehension make the key names all upper case.
"""

vehicles = {"Sedan": 1500, "SUV": 2000, "Truck": 2500, "Minivan": 1600, "Van": 2400, "Bicycle": 7, "Motorcycle": 110}

under_2000 = [car.upper() for car in vehicles if vehicles.get(car) < 2000]
print(under_2000)

# 2 points

"""# Problem Three: Complex Data Structure and List Comprehension

Convert the following list of dictionaries using list comprehension into a list of tuples (just the values).

Challenge: Make your_list[0] the keys in the dictionary
"""

records = [
    {'dna' : 'actgctagt', 'accession' : 'ABC123', 'genetic_code' : 1},
    {'dna' : 'ttaggttta', 'accession' : 'XYZ456', 'genetic_code' : 1},
    {'dna' : 'cgcgatcgt', 'accession' : 'HIJ789', 'genetic_code' : 5}
]

# using list comprehension 3
def conv_dic(dic):
  temp_list = [] # .5 point
  for key in dic:
    temp_list.append(str(dic[key]))
  return tuple(temp_list)
your_list = [conv_dic(dic) for dic in records] # 1 point
print(your_list)

"""find a method that can calculate the values for the dictionary and then conert that into a tuple

# Problem Four: Dictionary Comprehension

Use dictionary comprehension to rewrite the following for loops and if condition
"""

s = {}
for n in range(12):
    if n%2 == 1:
        for m in range(3, 5):
            s[(m, n)] = m + n
print (s)

#Your Code:

d = {(m,n):m+n for n in range(12) if n%2 == 1 for m in range(3,5)}
print(d)

# 2 points