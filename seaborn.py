# -*- coding: utf-8 -*-
"""Seaborn.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iA6rIrFO2pxdCRHEBs0xiqRDyvCDKdPj

## Introduction to Seaborn: statistical data visualization
<table><border=0><tr><td><img src="http://seaborn.pydata.org/_static/scatterplot_matrix_thumb.png" width="100"></td><td><img src="http://seaborn.pydata.org/_static/errorband_lineplots_thumb.png" width="100"></td><td><img src="http://seaborn.pydata.org/_static/scatterplot_sizes_thumb.png" width="100"></td><td><img src="http://seaborn.pydata.org/_static/timeseries_facets_thumb.png" width="100"></td><td><img src="http://seaborn.pydata.org/_static/horizontal_boxplot_thumb.png" width="100"></td><td><img src="http://seaborn.pydata.org/_static/regression_marginals_thumb.png" width="100"></td></tr></table>
    

[Seaborn_API_reference](http://seaborn.pydata.org/api.html)
    
We will use the eukaryote genome data file to learn how to create meaningful visualization that helps summarize the large amount of data effectively.
"""

import pandas as pd
# this input file is tab-delimited instead of comma-delimited
tsvFile = "https://raw.githubusercontent.com/csbfx/py22b/master/euk.tsv"

euk = pd.read_csv(tsvFile, sep="\t")

#head, tail, info

euk.head(12)

euk.tail()

euk.info()

#dtypes, shape, describe

euk.dtypes

euk.shape

euk.describe()

"""Notice that the fields `Speices`, `Kingdom`, `Class`, and `Assembly status` all contain strings, and some of the numeric fields contains "-" instead of a number. Let's clean up the dataframe before we proceed."""

#change strings from objects to strings

my_types={
    "Species": "string",
    "Kingdom": "string",
    "Class": "string",
    "Assembly status": "string"
}
euk = pd.read_csv(tsvFile, sep = "\t", dtype = my_types)

euk.head(10)

euk.info()

list1 = ['None','b','c','d']
list2 = [1,'-',4,7]
df = pd.DataFrame({"Names": list1, "Scores": list2})
df.to_csv("test.csv")
df

test = pd.read_csv('test.csv', na_values=['-', "None"])
print(test['Names'])
upperCase = test['Names'].str.upper()
upperCase

#reread

euk = pd.read_csv(tsvFile, sep = "\t", dtype = my_types, na_values = ["-"])

#info

euk.info()

euk.drop(columns=["Publication year"]).describe()

"""## Visualizing relationship between two variables

Now, let's face the truth. We are not very good at seeing patterns by reading large tables of data. For example, look at the following table that contains the genome size and the number of genes for reptiles. Can you see the relationship between genome size and the number of genes?
"""

#filter and remove outliers

euk = euk.dropna(subset=['Number of genes'])
selected = euk[(euk.Class == "Reptiles") & (euk["Size (Mb)"] < 4000) & (euk["Number of genes"]>15000)]
selected.shape

selected[["Species", "Size (Mb)", "Number of genes"]]

"""This is a small dataset, and it's already quite challenging to spot the relationship. Let's try to view this data by creating a scatter plot using seaborn. It's common to use `sns` as an alias for seaborn. We will also use the `pyplot` module from the `matplotlib` package, and we will use `plt` as the alias."""

import seaborn as sns
import matplotlib.pyplot as plt

"""If you are using Jupyter, %matplotlib inline, is a special Juypter command, to render and display the plot in Juypter notebook."""

# Commented out IPython magic to ensure Python compatibility.
# %matplotlib inline

sns.relplot(data = selected, x="Size (Mb)", y="Number of genes")
plt.title("Genomic Size (Mb) vs Number of genes in Reptiles", pad =20);

"""### `relplot` - Relationship plot
We pass the dataframe into the `relplot` function, and the names of the columns that we want on the `X` and `Y` axes. Let's look at the relationship between genome size and number of genes in the entire eukaryote genome dataset:
"""

sns.relplot(data = euk, x="Size (Mb)", y="Number of genes")
plt.title("Genomic Size (Mb) vs Number of genes in Eukaryotes", pad =20);

sns.relplot(data = euk[euk["Size (Mb)"]<5000], x="Size (Mb)", y="Number of genes")
plt.title("Genomic Size (Mb) vs Number of genes in Eukaryotes", pad =20);

"""Rather than giving relplot a collection of X and Y values to plot, instead we give it the whole dataframe and then specify which columns we want to determine the X and Y positions of each point.

The benefits of this way of thinking about plots become clear when we start mapping other properties. By setting the hue argument we can specify which column we want to determine the color of each point. Here’s another plot of genome size versus number of genes, this time limited to animals and with the GC percentage represented by hue. It’s best to remove any rows with missing data before plotting our data so that it won't impact seaborn's ability to choose the color scales for the hue.
"""

animals = euk[euk["Kingdom"] == "Animals"].dropna()
animals.head()

sns.relplot(
    data = animals,
    x= "Size (Mb)",
    y = "Number of genes",
    hue = "GC%"
)
plt.title("Genomic Size (Mb) vs Number of genes in Animals along with GC%", pad =20);

"""You can choose different palette for using different colors by setting the `palette` argument in relplot. [seaborn_color_palettes](http://seaborn.pydata.org/tutorial/color_palettes.html)"""

sns.relplot(
    data = animals,
    x= "Size (Mb)",
    y = "Number of genes",
    hue = "GC%",
    palette = "viridis"
)
plt.title("Genomic Size (Mb) vs Number of genes in Animals along with GC%", pad =20);

"""If we pick our mapping carefully, this lets us see multiple relationships between variables in a single plot. Unsurprisingly, larger genomes have more genes, and tend to have more moderate GC percentages - all the extremes of GC percentage (i.e. very light or dark colors) are over to the left of the chart.

Another property that we can map is size. Let’s plot number of genes versus number of proteins and have the *size* of each point determined by the size of the genome. We use `size` argument to map the size of the dot to the size of the genome. The argument `sizes` determines the minimum and maximum sizes of the points we want on the plot.
"""

sns.relplot(
    data = animals,
    x= "Number of proteins",
    y = "Number of genes",
    size =  "Size (Mb)",
    sizes = (2, 250)
)

plt.title ("Number of proteins vs gene according to their Genomic Size");

"""Let's use both size and hue."""

sns.relplot(
    data = animals,
    x = "Number of proteins",
    size= "Size (Mb)",
    y = "Number of genes",
    hue = "GC%",
    palette = "viridis",
    sizes = (2, 250)
)

plt.title ("Number of proteins vs gene according to their Genomic Size and GC%");

"""As the more details we try to fit onto a chart the harder it is to interpret. The relative
importance of the different point properties is determined by the way that our vision works. Research has shown that we find it easiest to see patterns in the position of the points (X and Y), followed by the size and finally the hue, so take this into account when deciding which variables to map to which properties.

Remember that the starting point for all of these plots is a pandas dataframe, so we still have access to all the pandas tools that we saw previously. To plot something like gene density, which is not part of the original file, we just need to add it as a new column first:
"""

animals["Gene per Kb"] = animals["Number of genes"]/animals["Size (Mb)"]*1000

sns.relplot(
    data = animals,
    x = "Size (Mb)",
    y = "Gene per Kb",
    color = "blue"
)

plt.title ("Genomic size vs Gene Density");

animals.head()

"""## Special types of scatter plots

In this section, we will learn how to plot large number of data points. We will use a dataset that contains genome sequence assembly data.

<table border=0><tr><td><img src="https://media.biocompare.com/m/37/product/11182180-400x300.jpg" width=200></td><td><img src="https://contig.files.wordpress.com/2010/02/alignment.jpg" width=500></td><td>
<img src="https://slideplayer.com/slide/12967081/79/images/6/Sequence+assembly+Reads+Contigs+Scaffolds+6.jpg" width=300></td></tr></table>
"""

# This dataset has no missing data
contigs_url="https://raw.githubusercontent.com/csbfx/advpy122-data/master/contigs.csv"

con = pd.read_csv(contigs_url)
con.head()

con.shape
con.info()

#relplot
g=sns.relplot(data=con, x="GC", y="length")
plt.title("GC content vs length for all contigs", pad = 20);

#relplot without outliers
sns.relplot(data= con[con.length<400000],
           x="GC", y="length")
plt.title("GC content vs length for all contigs", pad = 20);

"""There is clearly some structure in this plot, but the sheer number of points being plotted make it hard to see. There are simply too many points on top of each other.

There are a few ways to cope with this. One option is to set the points to be transparent using the alpha argument. Setting alpha = 0.01 makes the each point on the plot 99% transparent and turns the circles into a fuzzy cloud, and makes it possible to discern some structure that we couldn’t see before.
"""

sns.relplot(data= con[con.length<100000],
           x="GC", y="length", alpha=0.10)
plt.title("GC content vs length for all contigs", pad = 20);

"""It certainly looks like there are several populations of contigs with different ranges of GC and length.

A similar idea is to shrink the points, which we can do by setting the s parameter (s is short for size - remember from earlier that the size parameter is used when we want the size of points to vary). We will also have to remove the border around each point by setting its line width to zero:
"""

sns.relplot(data= con[con.length<100000],
           x="GC", y="length", s = 1, linewidth=0)
plt.title("GC content vs length for all contigs", pad = 20);

"""### Jointplot

These first three approaches still use scatter plots, where individual data points are drawn. To get away from this, we could imagine dividing up the area of the chart into different regions and shading them based on the number of points in the area. This gives us a slightly more exotic type of chart - a hexbin. We can draw one in seaborn usingjointplot with the kind=hex argument:
"""

g= sns.jointplot(data= con[con.length<100000],
           x="GC", y="length", kind="hex", gridsize=20)
g.fig.suptitle("GC content vs length for all contigs", y=1.05);

"""This hexbin plot nicely illustrates one of its weaknesses: the outliers with large size effectively disappear from the chart, as there aren’t enough of them in any one hex to raise its density above the background level. This is a fundamental trade off that we see in many types of plots - being able to visualize large datasets generally means that we give up the ability to see individual points.

Given that we can’t actually see any data above about 40000 on the y axis, we may as well focus on the data that we can see by excluding contigs with length greater than 40000:

### `catplot` - Categorical plot
In lecture 4 we counted the number of species in each Class of Animals using `value_counts()`. Let's make a plot to visualize these counts using seaborn's `catplot`. `catplot` takes in a long-form (tidy) dataframe for plotting. In a tidy dataframe, each column should correspond to a variable, and each row should correspond to an observation. Here we created a tidy dataframe, `animals_df`, that contains the Class name of each observation of an Animal.
"""

# use to_frame() to convert a Series to a Dataframe

animals_df = euk.Class[euk["Kingdom"] == "Animals"].to_frame()
animals_df.columns = ["Animals"]
animals_df.Animals.value_counts()
#animals_df

"""There are many kinds of catplot. Here we are setting x='Animals' and kind='count' because we are plotting barplot that represents the counts of each unique obersvation (counts of unique types of Animals)."""

sns.catplot(
    data = animals_df,
    x="Animals",
    kind = "count"
).set_axis_labels("Class of Animals", "Number of Species");

"""We can improve the plot by ordering the bars based on the height, and also swap the x and y axis to avoid having overlapping data along the x-axis. We don't really need different colors for each bar in this plot since the bars are already labeled. We will set the color to 'darkblue'."""

sns.catplot(
    data=animals_df,
    y="Animals",
    kind="count",
    order = animals_df.Animals.value_counts().index,
    color = "darkblue"
).set_axis_labels("Number of Species", "Class of Animals");

"""Let's take a closer look at the order argument. We use value_counts() to get the counts of each unique Animals. The resulting Series output by value_counts() is already sorted. Simply add .index to get the index of each Class of Animals in the sorted order."""

animals_df.Animals.value_counts().index